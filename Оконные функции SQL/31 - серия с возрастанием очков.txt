Описание задачи:

🤔 Серия с возрастанием очков
Есть таблица activity, которая хранит баллы, набранные пользователями в конкретные дни:

┌────────────┬─────────┬────────┐
│   adate    │ user_id │ points │
├────────────┼─────────┼────────┤
│ 2020-02-01 │ 51      │ 1      │
│ 2020-02-02 │ 11      │ 1      │
│ 2020-02-02 │ 51      │ 3      │
│ 2020-02-05 │ 21      │ 6      │
│ ...        │ ...     │ ...    │
│ 2020-02-25 │ 51      │ 1      │
└────────────┴─────────┴────────┘
Серией в этой задаче будем считать последовательность дней, в которых количество набранных пользователем очков в каждый следующий день не меньше, чем в предыдущий. При этом между предыдущим и следующим днем может быть любой промежуток времени, это не прерывает серию. Серии из одного дня не учитываем.

Например, это все одна серия:

01.02 — 1 балл,
05.02 — 2 балла,
10.02 — 3 балла.
А это не считается серией, несмотря на то, что дни идут без промежутков:

01.02 — 3 балла,
02.02 — 2 балла,
03.02 — 1 балл.
Напишите запрос, который считает серии для каждого пользователя.

Должно получиться так:

┌─────────┬────────────┬────────────┬───────────┬─────────┐
│ user_id │ day_start  │  day_end   │ day_count │ p_total │
├─────────┼────────────┼────────────┼───────────┼─────────┤
│ 11      │ 2020-02-02 │ 2020-02-17 │ 13        │ 16      │
│ 21      │ 2020-02-07 │ 2020-02-11 │ 3         │ 12      │
│ 21      │ 2020-02-13 │ 2020-02-20 │ 3         │ 13      │
│ 31      │ 2020-02-11 │ 2020-02-12 │ 2         │ 5       │
│ 51      │ 2020-02-01 │ 2020-02-02 │ 2         │ 4       │
│ 51      │ 2020-02-03 │ 2020-02-04 │ 2         │ 8       │
│ 51      │ 2020-02-08 │ 2020-02-21 │ 5         │ 27      │
└─────────┴────────────┴────────────┴───────────┴─────────┘
day_count — количество дней в серии, в которых пользователь заработал баллы;
p_total — сумма заработанных баллов за серию.
Сортировка результата: user_id, day_start
-----------------------------------------------------------------------------------
Моё решение:

WITH nlags AS (
SELECT user_id, adate, points,
LAG(points) OVER w AS nlag
FROM activity
WINDOW w AS (PARTITION BY user_id ORDER BY adate)
ORDER BY user_id, adate
)
, ngroups AS (
SELECT *,
SUM(CASE WHEN points - nlag < 0 THEN 1 ELSE 0 END) OVER w AS group_id
FROM nlags
WINDOW w AS (PARTITION BY user_id ORDER BY adate)
)
SELECT user_id,
MIN(adate) AS day_start,
MAX(adate) AS day_end,
COUNT(*) AS day_count,
SUM(points) AS p_total
FROM ngroups
GROUP BY user_id, group_id
HAVING day_count >1
ORDER BY user_id